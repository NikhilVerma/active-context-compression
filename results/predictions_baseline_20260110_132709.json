[
  {
    "instance_id": "mwaskom__seaborn-2848",
    "model_name_or_path": "claude-haiku-4-5-20251001_baseline",
    "model_patch": ""
  },
  {
    "instance_id": "pallets__flask-4045",
    "model_name_or_path": "claude-haiku-4-5-20251001_baseline",
    "model_patch": "diff --git a/src/flask/blueprints.py b/src/flask/blueprints.py\nindex 5fb84d86..823995f6 100644\n--- a/src/flask/blueprints.py\n+++ b/src/flask/blueprints.py\n@@ -188,6 +188,10 @@ class Blueprint(Scaffold):\n             template_folder=template_folder,\n             root_path=root_path,\n         )\n+\n+        if \".\" in name:\n+            raise ValueError(\"'name' may not contain a dot '.' character.\")\n+\n         self.name = name\n         self.url_prefix = url_prefix\n         self.subdomain = subdomain\n@@ -360,12 +364,12 @@ class Blueprint(Scaffold):\n         \"\"\"Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for\n         the :func:`url_for` function is prefixed with the name of the blueprint.\n         \"\"\"\n-        if endpoint:\n-            assert \".\" not in endpoint, \"Blueprint endpoints should not contain dots\"\n-        if view_func and hasattr(view_func, \"__name__\"):\n-            assert (\n-                \".\" not in view_func.__name__\n-            ), \"Blueprint view function name should not contain dots\"\n+        if endpoint and \".\" in endpoint:\n+            raise ValueError(\"'endpoint' may not contain a dot '.' character.\")\n+\n+        if view_func and hasattr(view_func, \"__name__\") and \".\" in view_func.__name__:\n+            raise ValueError(\"'view_func' name may not contain a dot '.' character.\")\n+\n         self.record(lambda s: s.add_url_rule(rule, endpoint, view_func, **options))\n \n     def app_template_filter(self, name: t.Optional[str] = None) -> t.Callable:\ndiff --git a/tests/test_basic.py b/tests/test_basic.py\nindex d6ec3fe4..7bdeba1e 100644\n--- a/tests/test_basic.py\n+++ b/tests/test_basic.py\n@@ -1631,7 +1631,7 @@ def test_url_processors(app, client):\n \n \n def test_inject_blueprint_url_defaults(app):\n-    bp = flask.Blueprint(\"foo.bar.baz\", __name__, template_folder=\"template\")\n+    bp = flask.Blueprint(\"foo\", __name__, template_folder=\"template\")\n \n     @bp.url_defaults\n     def bp_defaults(endpoint, values):\n@@ -1644,12 +1644,12 @@ def test_inject_blueprint_url_defaults(app):\n     app.register_blueprint(bp)\n \n     values = dict()\n-    app.inject_url_defaults(\"foo.bar.baz.view\", values)\n+    app.inject_url_defaults(\"foo.view\", values)\n     expected = dict(page=\"login\")\n     assert values == expected\n \n     with app.test_request_context(\"/somepage\"):\n-        url = flask.url_for(\"foo.bar.baz.view\")\n+        url = flask.url_for(\"foo.view\")\n     expected = \"/login\"\n     assert url == expected\n \ndiff --git a/tests/test_blueprints.py b/tests/test_blueprints.py\nindex b986ca02..cfcb43b3 100644\n--- a/tests/test_blueprints.py\n+++ b/tests/test_blueprints.py\n@@ -1,5 +1,3 @@\n-import functools\n-\n import pytest\n from jinja2 import TemplateNotFound\n from werkzeug.http import parse_cache_control_header\n@@ -253,28 +251,9 @@ def test_templates_list(test_apps):\n     assert templates == [\"admin/index.html\", \"frontend/index.html\"]\n \n \n-def test_dotted_names(app, client):\n-    frontend = flask.Blueprint(\"myapp.frontend\", __name__)\n-    backend = flask.Blueprint(\"myapp.backend\", __name__)\n-\n-    @frontend.route(\"/fe\")\n-    def frontend_index():\n-        return flask.url_for(\"myapp.backend.backend_index\")\n-\n-    @frontend.route(\"/fe2\")\n-    def frontend_page2():\n-        return flask.url_for(\".frontend_index\")\n-\n-    @backend.route(\"/be\")\n-    def backend_index():\n-        return flask.url_for(\"myapp.frontend.frontend_index\")\n-\n-    app.register_blueprint(frontend)\n-    app.register_blueprint(backend)\n-\n-    assert client.get(\"/fe\").data.strip() == b\"/be\"\n-    assert client.get(\"/fe2\").data.strip() == b\"/fe\"\n-    assert client.get(\"/be\").data.strip() == b\"/fe\"\n+def test_dotted_name_not_allowed(app, client):\n+    with pytest.raises(ValueError):\n+        flask.Blueprint(\"app.ui\", __name__)\n \n \n def test_dotted_names_from_app(app, client):\n@@ -343,62 +322,19 @@ def test_route_decorator_custom_endpoint(app, client):\n def test_route_decorator_custom_endpoint_with_dots(app, client):\n     bp = flask.Blueprint(\"bp\", __name__)\n \n-    @bp.route(\"/foo\")\n-    def foo():\n-        return flask.request.endpoint\n+    with pytest.raises(ValueError):\n+        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n \n-    try:\n+    with pytest.raises(ValueError):\n+        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n \n-        @bp.route(\"/bar\", endpoint=\"bar.bar\")\n-        def foo_bar():\n-            return flask.request.endpoint\n+    def view():\n+        return \"\"\n \n-    except AssertionError:\n-        pass\n-    else:\n-        raise AssertionError(\"expected AssertionError not raised\")\n+    view.__name__ = \"a.b\"\n \n-    try:\n-\n-        @bp.route(\"/bar/123\", endpoint=\"bar.123\")\n-        def foo_bar_foo():\n-            return flask.request.endpoint\n-\n-    except AssertionError:\n-        pass\n-    else:\n-        raise AssertionError(\"expected AssertionError not raised\")\n-\n-    def foo_foo_foo():\n-        pass\n-\n-    pytest.raises(\n-        AssertionError,\n-        lambda: bp.add_url_rule(\"/bar/123\", endpoint=\"bar.123\", view_func=foo_foo_foo),\n-    )\n-\n-    pytest.raises(\n-        AssertionError, bp.route(\"/bar/123\", endpoint=\"bar.123\"), lambda: None\n-    )\n-\n-    foo_foo_foo.__name__ = \"bar.123\"\n-\n-    pytest.raises(\n-        AssertionError, lambda: bp.add_url_rule(\"/bar/123\", view_func=foo_foo_foo)\n-    )\n-\n-    bp.add_url_rule(\n-        \"/bar/456\", endpoint=\"foofoofoo\", view_func=functools.partial(foo_foo_foo)\n-    )\n-\n-    app.register_blueprint(bp, url_prefix=\"/py\")\n-\n-    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n-    # The rule's didn't actually made it through\n-    rv = client.get(\"/py/bar\")\n-    assert rv.status_code == 404\n-    rv = client.get(\"/py/bar/123\")\n-    assert rv.status_code == 404\n+    with pytest.raises(ValueError):\n+        bp.add_url_rule(\"/\", view_func=view)\n \n \n def test_endpoint_decorator(app, client):\n"
  },
  {
    "instance_id": "psf__requests-2148",
    "model_name_or_path": "claude-haiku-4-5-20251001_baseline",
    "model_patch": "diff --git a/requests/models.py b/requests/models.py\nindex 0dc55568..2ababaf8 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -9,6 +9,7 @@ This module contains the primary objects that power Requests.\n \n import collections\n import datetime\n+import socket\n \n from io import BytesIO, UnsupportedOperation\n from .hooks import default_hooks\n@@ -22,7 +23,7 @@ from .packages.urllib3.util import parse_url\n from .packages.urllib3.exceptions import DecodeError\n from .exceptions import (\n     HTTPError, RequestException, MissingSchema, InvalidURL,\n-    ChunkedEncodingError, ContentDecodingError)\n+    ChunkedEncodingError, ContentDecodingError, ConnectionError)\n from .utils import (\n     guess_filename, get_auth_from_url, requote_uri,\n     stream_decode_response_unicode, to_key_val_list, parse_header_links,\n@@ -640,6 +641,8 @@ class Response(object):\n                     raise ChunkedEncodingError(e)\n                 except DecodeError as e:\n                     raise ContentDecodingError(e)\n+                except socket.error as e:\n+                    raise ConnectionError(e)\n             except AttributeError:\n                 # Standard file-like object.\n                 while True:\n"
  },
  {
    "instance_id": "pylint-dev__pylint-5859",
    "model_name_or_path": "claude-haiku-4-5-20251001_baseline",
    "model_patch": "diff --git a/pylint/checkers/misc.py b/pylint/checkers/misc.py\nindex 69149e61a..28978365f 100644\n--- a/pylint/checkers/misc.py\n+++ b/pylint/checkers/misc.py\n@@ -121,9 +121,9 @@ class EncodingChecker(BaseChecker):\n \n         notes = \"|\".join(re.escape(note) for note in self.config.notes)\n         if self.config.notes_rgx:\n-            regex_string = rf\"#\\s*({notes}|{self.config.notes_rgx})\\b\"\n+            regex_string = rf\"#\\s*({notes}|{self.config.notes_rgx})(?=\\W|$)\"\n         else:\n-            regex_string = rf\"#\\s*({notes})\\b\"\n+            regex_string = rf\"#\\s*({notes})(?=\\W|$)\"\n \n         self._fixme_pattern = re.compile(regex_string, re.I)\n \ndiff --git a/tests/checkers/unittest_misc.py b/tests/checkers/unittest_misc.py\nindex 23e19a9d0..102055f07 100644\n--- a/tests/checkers/unittest_misc.py\n+++ b/tests/checkers/unittest_misc.py\n@@ -120,3 +120,45 @@ class TestFixme(CheckerTestCase):\n         \"\"\"\n         with self.assertNoMessages():\n             self.checker.process_tokens(_tokenize_str(code))\n+\n+    @set_config(notes=[\"YES\", \"???\"])\n+    def test_punctuation_only_note_tags(self) -> None:\n+        \"\"\"Test that note tags consisting entirely of punctuation are recognized.\n+        \n+        This is a regression test for the issue where note tags that are entirely\n+        punctuation (like ???) were not being recognized because the regex pattern\n+        used \\\\b (word boundary) which doesn't work with non-word characters.\n+        \"\"\"\n+        code = \"\"\"a = 1\n+                # YES: yes\n+                # ???: no\n+                \"\"\"\n+        with self.assertAddsMessages(\n+            [\n+                MessageTest(msg_id=\"fixme\", line=2, args=\"YES: yes\", col_offset=17),\n+                MessageTest(msg_id=\"fixme\", line=3, args=\"???: no\", col_offset=17),\n+            ]\n+        ):\n+            self.checker.process_tokens(_tokenize_str(code))\n+\n+    @set_config(notes=[\"???\"])\n+    def test_punctuation_only_note_tag_alone(self) -> None:\n+        \"\"\"Test that punctuation-only note tags work when used alone.\"\"\"\n+        code = \"\"\"a = 1\n+                # ???\n+                \"\"\"\n+        with self.assertAddsMessages(\n+            MessageTest(msg_id=\"fixme\", line=2, args=\"???\", col_offset=17)\n+        ):\n+            self.checker.process_tokens(_tokenize_str(code))\n+\n+    @set_config(notes=[\"!!!\"])\n+    def test_multiple_punctuation_note_tag(self) -> None:\n+        \"\"\"Test that multiple punctuation characters work as note tags.\"\"\"\n+        code = \"\"\"a = 1\n+                # !!!: important\n+                \"\"\"\n+        with self.assertAddsMessages(\n+            MessageTest(msg_id=\"fixme\", line=2, args=\"!!!: important\", col_offset=17)\n+        ):\n+            self.checker.process_tokens(_tokenize_str(code))\n"
  },
  {
    "instance_id": "scikit-learn__scikit-learn-10297",
    "model_name_or_path": "claude-haiku-4-5-20251001_baseline",
    "model_patch": "diff --git a/sklearn/linear_model/ridge.py b/sklearn/linear_model/ridge.py\nindex 911c74ae3b..6469cdbcfc 100644\n--- a/sklearn/linear_model/ridge.py\n+++ b/sklearn/linear_model/ridge.py\n@@ -1301,6 +1301,12 @@ class RidgeClassifierCV(LinearClassifierMixin, _BaseRidgeCV):\n         weights inversely proportional to class frequencies in the input data\n         as ``n_samples / (n_classes * np.bincount(y))``\n \n+    store_cv_values : boolean, default=False\n+        Flag indicating if the cross-validation values corresponding to\n+        each alpha should be stored in the `cv_values_` attribute (see\n+        below). This flag is only compatible with `cv=None` (i.e. using\n+        Generalized Cross-Validation).\n+\n     Attributes\n     ----------\n     cv_values_ : array, shape = [n_samples, n_alphas] or \\\n@@ -1333,10 +1339,11 @@ class RidgeClassifierCV(LinearClassifierMixin, _BaseRidgeCV):\n     advantage of the multi-variate response support in Ridge.\n     \"\"\"\n     def __init__(self, alphas=(0.1, 1.0, 10.0), fit_intercept=True,\n-                 normalize=False, scoring=None, cv=None, class_weight=None):\n+                 normalize=False, scoring=None, cv=None, class_weight=None,\n+                 store_cv_values=False):\n         super(RidgeClassifierCV, self).__init__(\n             alphas=alphas, fit_intercept=fit_intercept, normalize=normalize,\n-            scoring=scoring, cv=cv)\n+            scoring=scoring, cv=cv, store_cv_values=store_cv_values)\n         self.class_weight = class_weight\n \n     def fit(self, X, y, sample_weight=None):\ndiff --git a/sklearn/linear_model/tests/test_ridge.py b/sklearn/linear_model/tests/test_ridge.py\nindex ee44da5d56..5c943190d0 100644\n--- a/sklearn/linear_model/tests/test_ridge.py\n+++ b/sklearn/linear_model/tests/test_ridge.py\n@@ -860,3 +860,19 @@ def test_dtype_match_cholesky():\n     assert ridge_32.predict(X_32).dtype == X_32.dtype\n     assert ridge_64.predict(X_64).dtype == X_64.dtype\n     assert_almost_equal(ridge_32.coef_, ridge_64.coef_, decimal=5)\n+\n+\n+def test_ridge_classifier_cv_store_cv_values():\n+    # Test RidgeClassifierCV's store_cv_values attribute.\n+    rng = np.random.RandomState(42)\n+\n+    n_samples = 8\n+    n_features = 5\n+    x = rng.randn(n_samples, n_features)\n+    y = rng.randint(0, 2, n_samples)\n+    alphas = [1e-1, 1e0, 1e1]\n+    n_alphas = len(alphas)\n+\n+    r = RidgeClassifierCV(alphas=alphas, store_cv_values=True)\n+    r.fit(x, y)\n+    assert_equal(r.cv_values_.shape, (n_samples, n_alphas))\n"
  }
]